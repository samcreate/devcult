// Generated by CoffeeScript 1.7.0
(function() {
  var Extensions, compiled_ext, static_ext, _;

  _ = require('lodash');

  compiled_ext = require('./extensions/compiled');

  static_ext = require('./extensions/static');


  /**
   * @class Extensions
   * @classdesc Responsible for managing roots extensions
   * @todo could this be an array with methods on it rather than a class?
   */

  Extensions = (function() {
    var check_extension_errors, hooks, not_function;

    function Extensions(roots) {
      this.roots = roots;
      this.all = [];
      this.register([compiled_ext(), static_ext()]);
    }


    /**
     * Registers roots extension(s) with your project. Tests each extension passed
     * to ensure it's the right type, then flips the extensions backwards and pushes
     * each one to the beginning of the array, conserving order, unless there's a priority
     * given, in which case it's inserted at a certain index.
     * 
     * @param  {Object} extensions - an extension or array of extensions
     * @param  {Integer} priority - optional, how early the extension(s) is/are run
     */

    Extensions.prototype.register = function(extensions, priority) {
      var ext, _i, _len, _ref, _results;
      if (!Array.isArray(extensions)) {
        extensions = [extensions];
      }
      _ref = extensions.reverse();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        ext = _ref[_i];
        if (typeof ext !== 'function') {
          this.roots.bail(125, "Extension must return a function/class", ext);
        }
        if (priority != null) {
          _results.push(this.all.unshift(ext));
        } else {
          _results.push(this.all.splice(priority, 0, ext));
        }
      }
      return _results;
    };


    /**
     * Create a new instance of each extension, checking for any sort of errors
     * in the way the extension was configured.
     * 
     * @return {Array} - array of instantiated extensions
     */

    Extensions.prototype.instantiate = function() {
      var extensions;
      extensions = this.all.map((function(_this) {
        return function(Ext) {
          var err, ext;
          try {
            ext = new Ext(_this.roots);
          } catch (_error) {
            err = _error;
            _this.roots.bail(125, err, ext);
          }
          check_extension_errors(ext);
          return ext;
        };
      })(this));
      extensions.hooks = hooks.bind(extensions);
      return extensions;
    };


    /**
     * Ensures that all existant properties of an extension are functions.
     * 
     * @param  {Function} ext - instance of an extension
     */

    check_extension_errors = function(ext) {
      if (not_function(ext.fs)) {
        this.roots.bail(125, 'The fs property must be a function', ext);
      }
      if (not_function(ext.compile_hooks)) {
        this.roots.bail(125, 'The compile_hooks property must be a function', ext);
      }
      if (not_function(ext.category_hooks)) {
        return this.roots.bail(125, 'The category_hooks property must be a function', ext);
      }
    };


    /**
     * If exists and is not a function. Helper.
     *
     * @private
     * 
     * @param  {???} prop - anything
     * @return {Boolean} whether it exists and is not a function or not
     */

    not_function = function(prop) {
      return prop && typeof prop !== 'function';
    };


    /**
     * Returns a given extension's hook, if it exists. The nitty gritty:
     *
     * - Takes a hook name like 'compile_hooks.before'
     * - Splits it to a namespace and key at the period
     * - If an object is not returned, bail. This piece uses a really
     *   dirty hack to get access to the roots object out of scope.
     * - For each extension, if that namespace and key both exist
     *   and the extension is in its category, return the key
     * 
     * @param  {String} name - hook name, separated with periods
     * @return {Function}      the hook function if exists, otherwise undefined
     */

    hooks = function(name, category) {
      var key, namespace;
      namespace = name.split('.')[0];
      key = name.split('.')[1];
      return _.compact(this.map((function(_this) {
        return function(ext) {
          var called_namespace;
          if (!ext[namespace]) {
            return;
          }
          called_namespace = ext[namespace]();
          if (typeof called_namespace !== 'object') {
            _this[_this.length - 2].roots.bail(125, "" + namespace + " should return an object", ext);
          }
          if (called_namespace.category) {
            if (called_namespace.category !== category) {
              return;
            }
          } else {
            if (ext.category && ext.category !== category) {
              return;
            }
          }
          return called_namespace[key];
        };
      })(this)));
    };

    return Extensions;

  })();

  module.exports = Extensions;

}).call(this);
