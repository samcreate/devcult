// Generated by CoffeeScript 1.7.0
(function() {
  var FSParser, File, W, fs, minimatch, path, pipeline, readdirp, _;

  fs = require('fs');

  path = require('path');

  W = require('when');

  readdirp = require('readdirp');

  _ = require('lodash');

  minimatch = require('minimatch');

  pipeline = require('when/pipeline');

  File = require('vinyl');


  /**
   * @class FS Parser
   * @classdesc Recursively parses the project folder, producing an object
   *            which puts each file into a category for processing.
   */

  FSParser = (function() {

    /**
     * Creates a new instance of the FSParser class. Sets up instance vars:
     * 
     * - root: the project root
     * - config: roots config object
     * - extensions: all extension instances for this compile
     * 
     * @param  {Function} roots - instance of the roots base class
     */
    var format_dirs, ignored, parse_dir, parse_file, sort;

    function FSParser(roots, extensions) {
      this.roots = roots;
      this.extensions = extensions;
      this.root = this.roots.root;
      this.config = this.roots.config;
    }


    /**
     * Parses the roots base class' root path, whether file or directory
     * returns an "ast" representing the files categorized by the way they
     * need to be parsed. The ast is an object with the key being the
     * category name and the value being an array of vinyl file instances.
     * It would look something like this (with one 'example' extension):
     *
     * {
     *   compiled: [<File>, <File>],
     *   example: [<File>, <File>, <File>],
     *   static: [<File>]
     * }
     * 
     * @return {Object} when.js promise for an ast
     */

    FSParser.prototype.parse = function() {
      this.ast = {
        dirs: []
      };
      if (fs.statSync(this.root).isDirectory()) {
        return parse_dir.call(this, this.root);
      } else {
        return parse_file.call(this, this.root);
      }
    };


    /**
     * Parses the root as a directory, reading it recursively, adding
     * all subdirectories to the `dirs` category, and parsing all files
     * with the `parse_file` method below.
     *
     * @private
     * 
     * @param  {String} dir - path to a directory
     * @return {Object} 'ast' object, described above
     */

    parse_dir = function(dir) {
      var deferred, files;
      deferred = W.defer();
      files = [];
      readdirp({
        root: dir,
        directoryFilter: ['!.git', '!node_modules']
      }).on('end', (function(_this) {
        return function() {
          return deferred.resolve(W.all(files).then(format_dirs.bind(_this)));
        };
      })(this)).on('error', deferred.reject).on('data', (function(_this) {
        return function(f) {
          if (ignored.call(_this, f.path)) {
            return;
          }
          if (f.parentDir.length) {
            _this.ast.dirs.push(f.fullParentDir);
          }
          return files.push(parse_file.call(_this, f.fullPath));
        };
      })(this));
      return deferred.promise;
    };


    /**
     * Goes through each extension and runs it's `detect` function for the
     * provided file. If it passes, the file is added to that extension's category.
     * The roots default `static` extension runs last and collects any and all
     * files that were not sorted into other categories.
     *
     * Also note the partial application and use of `when/pipeline`. We bind each
     * extension and the file to the `sort` function upfront, and leave only the last
     * parameter to be set, which represents `extract`, discussed below. Pipeline
     * calls each function in an array in order, passing the results of the last
     * function to the next one. The arg provided to pipeline is what goes to the
     * first function in the list. Detailed docs for pipeline found here:
     *
     * https://github.com/cujojs/when/blob/master/docs/api.md#whenpipeline
     *
     * This method also wraps each file in a vinyl wrapper. More info in vinyl:
     * https://github.com/wearefractal/vinyl
     *
     * @private
     * 
     * @param  {String} file - path to a file
     */

    parse_file = function(file) {
      var ext, list;
      file = new File({
        base: this.root,
        path: file
      });
      list = (function() {
        var _i, _len, _ref, _results;
        _ref = this.extensions;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          ext = _ref[_i];
          if (ext.fs) {
            _results.push(sort.bind(this, ext, file));
          }
        }
        return _results;
      }).call(this);
      return pipeline(list, false)["yield"](this.ast);
    };


    /**
     * Given a file and an extension, runs the extension's `detect` function
     * on the file. If it returns false, the file is not added to the extension's
     * category and the function returns. If true, the file is added to the
     * extension's category.
     * 
     * After this, if the extension has `extract` set to true, meaning that once
     * a file has been added to it's category, it's not eligable to be added to any
     * other category, it returns `true`. At the top of the sort function, if `true`
     * comes in (meaning a file has been added to a category and extracted), it will
     * skip any detection and continue passing true down the line.
     *
     * The way pipeline works above, the result of one function is passed to the next.
     * So as soon as an extension returns true (aka file is extracted), detections will
     * not be run for any other extension, and therefore it will not be added to any
     * other categories.
     *
     * @private
     * 
     * @param  {Function} ext - a roots extension instance
     * @param  {File} file - vinyl wrapper for a file
     * @param  {Boolean} extract - if true, function is skipped
     * @return {Boolean} promise for a boolean, passed as extract to next function
     *
     * @todo handle error if ext.fs doesn't return an object
     * @todo handle error if ext.fs.detect doesn't exist
     * @todo handle error if category not found
     */

    sort = function(ext, file, extract) {
      var extfs;
      if (extract) {
        return true;
      }
      extfs = ext.fs();
      return W.resolve(extfs.detect(file)).then((function(_this) {
        return function(detected) {
          var cat, _base;
          if (!detected) {
            return false;
          }
          cat = extfs.category || ext.category;
          if ((_base = _this.ast)[cat] == null) {
            _base[cat] = [];
          }
          if (!_.contains(_this.ast[cat], file)) {
            _this.ast[cat].push(file);
          }
          return extfs.extract;
        };
      })(this));
    };


    /**
     * Makes sure there are no duplicate directories and that they all directories
     * are passed through as vinyl-wrapped file objects.
     *
     * @private
     * 
     * @return {Object} - modified instance of the `ast`
     */

    format_dirs = function() {
      this.ast.dirs = _.uniq(this.ast.dirs).map((function(_this) {
        return function(d) {
          return new File({
            base: _this.root,
            path: d
          });
        };
      })(this));
      return this.ast;
    };


    /**
     * Checks a file against the ignored list to see if it should be skipped.
     * 
     * @param  {String} f - file path
     * @return {Boolean} whether the file should be ignored or not
     */

    ignored = function(f) {
      return this.config.ignores.map(function(i) {
        return minimatch(f, i, {
          dot: true
        });
      }).filter(function(i) {
        return i;
      }).length;
    };

    return FSParser;

  })();

  module.exports = FSParser;

}).call(this);
