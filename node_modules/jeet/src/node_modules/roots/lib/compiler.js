// Generated by CoffeeScript 1.7.0
(function() {
  var CompileFile, CompilePass, Compiler, File, W, fs, nodefn, path, pipeline, sequence, _;

  fs = require('graceful-fs');

  path = require('path');

  _ = require('lodash');

  W = require('when');

  nodefn = require('when/node');

  pipeline = require('when/pipeline');

  sequence = require('when/sequence');

  File = require('vinyl');


  /**
   * @class Compiler
   * @classdesc Responsible for compiling files, multipass included
   */

  Compiler = (function() {

    /**
     * Creates a new compiler instance, which holds on to the roots instance
     * as well as an array of initialized extensions, and creates an empty
     * options object, which is re-created per-compile.
     *
     * @param  {Function} @roots - Roots class instance
     * @param  {Function} @extensions - array of initialzed extensions
     */
    function Compiler(roots, extensions) {
      this.roots = roots;
      this.extensions = extensions;
      this.options = {};
    }


    /**
     * Compile a single file asynchronously.
     *
     * @param  {String} category - category the file is being compiled in
     * @param  {File} file - vinyl-wrapped file
     * @return {Promise} promise for the fully compiled file
     */

    Compiler.prototype.compile = function(category, file) {
      var cf;
      cf = new CompileFile(this.roots, this.extensions, this.options, category, file);
      return cf.run();
    };

    return Compiler;

  })();

  module.exports = Compiler;


  /**
   * @class CompileFile
   * @classdesc Compiles a single file, separate class to allow for working
   *            easily with a scope that doesn't interfere with anything else.
   * @private
   */

  CompileFile = (function() {

    /**
     * Creates a new instances of the CompileFile class. Grabs the adapter(s)
     * needed to compile the file, creates the per-file options object and adds
     * filename to it.
     *
     * @param  {Function} roots           Roots class instance
     * @param  {Array}    extensions      Array of initialzed extensions
     * @param  {Object}   compile_options Per-compile options object
     * @param  {String}   category        Category of file being compiled
     * @param  {File}     file            Vinyl-wrapped file
     */
    var each_pass, get_adapters, process_write_hook_results, read_file, write_file, write_task;

    function CompileFile(roots, extensions, compile_options, category, file) {
      this.roots = roots;
      this.extensions = extensions;
      this.compile_options = compile_options;
      this.category = category;
      this.file = file;
      this.adapters = get_adapters.call(this);
      this.is_compiled = !!_(this.adapters).pluck('name').compact().value().length;
      this.file_options = {
        filename: this.file.path
      };
    }


    /**
     * Initialize the actual compilation. This method is a higher level wrapper for
     * a promise chain, summarized as such:
     *
     * - reads the file's content, set on the instance
     * - run the before hooks for each extensions before_file hook
     * - take each pass over the file, and compile, set compiled content on instance
     * - emit a compile event once finished passing the file vinyl wrapper
     * - run the extensions' after hooks
     * - write the file
     *
     * @return {Promise} promise for a compiled and written file
     */

    CompileFile.prototype.run = function() {
      return read_file.call(this, this.file)["with"](this).then((function(_this) {
        return function(o) {
          return _this.content = o;
        };
      })(this)).then((function(_this) {
        return function() {
          return sequence(_this.extensions.hooks('compile_hooks.before_file', _this.category), _this);
        };
      })(this)).then(each_pass).tap((function(_this) {
        return function(o) {
          return _this.content = o;
        };
      })(this)).tap((function(_this) {
        return function() {
          return _this.roots.emit('compile', _this.file);
        };
      })(this)).then((function(_this) {
        return function() {
          return sequence(_this.extensions.hooks('compile_hooks.after_file', _this.category), _this);
        };
      })(this)).then(write_file);
    };


    /**
     * Async utf8 file read from a vinyl file wrapped in a promise.
     *
     * @private
     *
     * @param  {f} f - vinyl-wrapped file
     * @return {Promise} a promise for the file's contents
     */

    read_file = function(f) {
      var options, opts;
      options = null;
      opts = this.is_compiled ? {
        encoding: 'utf8'
      } : null;
      return nodefn.call(fs.readFile, f.path, opts);
    };


    /**
     * Writes a file from the content property on the instance. Can be modified
     * by a write_hook from an extension.
     *
     * - Run through extension write hooks
     * - Process the results of each and create write tasks (see below)
     * - Move on once all write tasks have been completed
     *
     * @private
     *
     * @return {Promise} promise for written file(s)
     *
     * @todo adjust config.out to work better with vinyl
     */

    write_file = function() {
      return sequence(this.extensions.hooks('compile_hooks.write', this.category), this).then(process_write_hook_results.bind(this)).then(W.all);
    };


    /**
     * Given an array of results from each extension's write_hook, if
     * present, figure out how to handle the actual writes, then delegate
     * them to one or multiple `write_task`s.
     *
     * - If there are no write hooks, file is written as usual
     * - If a write hook returns false, file is not written regardless of anything else
     * - If a write hook returns true, file is written as usual (once at max)
     * - If a write hook returns an object or array of objects with
     *   path and content props, the file(s) is/are written to the
     *   provided path(s) with the provided content(s)
     * - If a write hook returns anything else, roots bails
     *
     * We then return an array of promises for all write tasks.
     *
     * @param  {Array} results - results from all write hooks
     * @return {Array} an array of promises for written files
     *
     * @todo if custom path is given, it always also writes standard
     */

    process_write_hook_results = function(results) {
      var normal_write_pushed, res, write_tasks, _i, _len;
      if (results.length < 1) {
        return [write_task.call(this)];
      }
      if (_.contains(results, false)) {
        return [];
      }
      write_tasks = [];
      normal_write_pushed = false;
      for (_i = 0, _len = results.length; _i < _len; _i++) {
        res = results[_i];
        if (res === true) {
          if (!normal_write_pushed) {
            write_tasks.push(write_task.call(this));
          }
          normal_write_pushed = true;
        } else if (typeof res === 'object' && !Array.isArray(res)) {
          write_tasks.push(write_task.call(this, res));
        } else if (Array.isArray(res)) {
          write_tasks.concat(res.map((function(_this) {
            return function(i) {
              return write_task.call(_this, i);
            };
          })(this)));
        } else {
          this.roots.bail(126, 'invalid return from write_hook', res);
        }
      }
      return W.resolve(write_tasks);
    };


    /**
     * Single task to write a file. Accepts an optional object with the following
     * keys:
     *
     * - path: relative (to root) or absolute path to write to
     * - content: content to write
     * - extension: extension to write the file with
     *
     * If an object is passed, each of these keys is optional, and if not provided
     * will be filled in with default values. The path then is wrapped with vinyl,
     * passed through the roots output path generator, and the file is written.
     * The extension property is only set if there wasn't already an extension override
     * and there was a compile, otherwise any extensions are preserved as is.
     *
     * @param  {Object} obj - object with `path` and `content` properties
     * @return {Promise} a promise for the written file
     */

    write_task = function(obj) {
      if (obj == null) {
        obj = {};
      }
      obj = _.defaults(obj, {
        path: this.file,
        content: this.content
      });
      if ((obj.extension == null) && this.is_compiled) {
        obj.extension = _.last(this.adapters).output;
      }
      if (!(obj.path instanceof File)) {
        obj.path = new File({
          base: this.roots.root,
          path: obj.path
        });
      }
      obj.path = this.roots.config.out(obj.path, obj.extension);
      return nodefn.call(fs.writeFile, obj.path, obj.content);
    };


    /**
     * Read the file's extension and grab any and all adapters that match. If there
     * isn't a matching adapter, returns an adapter stub that is used to just copy
     * the file.
     *
     * If no adapters are found, it's a file with no extension, so it gets a stub
     * adapter with no extension.
     *
     * @return {Array} an array of adapter objects, in order
     */

    get_adapters = function() {
      var adapters, compiler, ext, extensions, _i, _len, _ref;
      extensions = path.basename(this.file.path).split('.').slice(1);
      adapters = [];
      _ref = _.clone(extensions).reverse();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        ext = _ref[_i];
        compiler = _.find(this.roots.config.compilers, function(c) {
          return _.contains(c.extensions, ext);
        });
        adapters.push(compiler ? compiler : {
          output: ext
        });
      }
      if (!adapters.length) {
        adapters.push({
          output: ''
        });
      }
      return adapters;
    };


    /**
     * Initializes the actual compilation of the file. Since each pass is it's
     * own task, it gets its own context. This method runs pipeline, which runs
     * through an array and passes one's output to the next. Before doing this,
     * it binds an adapter and an index to each compile pass.
     *
     * @return {Promise} a promise for the compiled content of the file
     */

    each_pass = function() {
      var pass;
      pass = new CompilePass(this);
      return pipeline(this.adapters.map((function(_this) {
        return function(a, i) {
          return pass.run.bind(pass, a, i + 1);
        };
      })(this)), this.content);
    };

    return CompileFile;

  })();


  /**
   * @class CompilePass
   * @classdesc Handles one compilation pass on a file's content.
   */

  CompilePass = (function() {

    /**
     * Creates a new instance, holding on to a reference to the CompileFile instance.
     * @param  {Function} file - instance of CompileFile
     */
    var compile_or_pass, configure_options;

    function CompilePass(file) {
      this.file = file;
    }


    /**
     * Initialize the compile. Takes an adapter, the index (number of the pass), and
     * content. It takes a couple steps:
     *
     * - First, get the options to be passed in with the adapter, described below
     * - Then execute any before pass hooks
     * - Then actually compile, or if no compilation needed just pass the content on
     * - Then set the content on the context
     * - Then execute any after_pass hooks
     * - Finally, return the content
     *
     * @param  {Object} @adapter - accord adapter to compile with
     * @param  {Integer} @index - # of the compile pass
     * @param  {String} @content - the content to be compiled
     * @return {Promise} a promise for the compiled content
     *
     * @todo is there a way to yield(@content)?
     */

    CompilePass.prototype.run = function(adapter, index, content) {
      this.adapter = adapter;
      this.index = index;
      this.content = content;
      this.opts = configure_options.call(this);
      return sequence(this.file.extensions.hooks('compile_hooks.before_pass', this.file.category), this)["with"](this).then(compile_or_pass).then((function(_this) {
        return function(o) {
          return _this.content = o;
        };
      })(this)).then((function(_this) {
        return function() {
          return sequence(_this.file.extensions.hooks('compile_hooks.after_pass', _this.file.category), _this);
        };
      })(this)).then((function(_this) {
        return function() {
          return _this.content;
        };
      })(this));
    };


    /**
     * This function is responsible for getting all the options together for the
     * compilation. Tried to be clear as possible here with the code, as you can
     * see there are 4 different options objects that are merged together to make
     * the package of options that are passed in for each file.
     *
     * - global options: set in app.coffee, these are options that are present in
     *   every file, no matter what
     * - adapter options: also set in app.coffee, these options are specific to an
     *   adapter. For example, setting `pretty` to `true` for jade only
     * - file options: options that persist only for a single file, for all passes
     * - compile options: options that persist through each time the project
     *   compiles, but are cleared between one compile and the next
     *
     * @private
     *
     * @return {Object} - all options merged into a single object
     */

    configure_options = function() {
      var adapter_options, compile_options, file_options, global_options;
      global_options = this.file.roots.config.locals || {};
      adapter_options = this.file.roots.config[this.adapter.name] || {};
      file_options = this.file.file_options;
      compile_options = this.file.compile_options;
      return _.extend(global_options, adapter_options, file_options, compile_options);
    };


    /**
     * As small of a function as this is, it's the one that actually is doing
     * the work to compile the files. First it checks if the adapter has a name,
     * which is a requirement of all accord adapters. If not, it's likely a stub
     * adapter used to copy the file, and it returns the content.
     *
     * If there is a name this means we have a legit adapter, and it runs the
     * compile and returns a promise for the content.
     *
     * @return {Promise|String} a string or promise for a string of content
     *
     * @todo maybe use instance rather than name to classify?
     */

    compile_or_pass = function() {
      if (!this.adapter.name) {
        return this.content;
      }
      return this.adapter.render(this.content, this.opts);
    };

    return CompilePass;

  })();

}).call(this);
